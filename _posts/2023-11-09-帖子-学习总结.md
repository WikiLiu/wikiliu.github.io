# RickLiu实习期学习工作总结

[工作流程部分](#工作流程部分)

[Linux图形栈部分](#Linux图形栈部分)

## 工作流程
### 1、Gerrit仓库
* Gerrit网页操作，查看、处理代码和发送reviewer等
* 学习复杂的git命令：cherry-pick、git commit -、***git rebase***，熟练的在vscode中处理git流程
### 2、BUG维修
* 熟悉Redmine和Gerrit的BUG上报和维修流程，根据不同结论添加报告

## Linux图形栈
* Xorg-xserver：2D driver驱动模块主要是arise_drv.so，
* drm：
* bit-blit：块传输图
* fence

## GLENFLY

## OpenGL
* OpenGL概述：opengl是一组应用层图形api，只是接口规范并不是具体实现，具体实现可走软件的mesa或vendor硬件实现。渲染管线包括：顶点绘制、图元
装配、光栅化、片段着色等基本流程， 对应着***顶点着色器、细分着色器、几何着色器、片段着色器***。

* OpenGL编程步骤：利用EGL或GLFW等中间层窗口框架创建渲染窗口，OGL在其创建的window或者surface上绘制；定义并编译GLSL的pipeline渲染代码，
最少包括顶点着色器和片段着色器；然后在上下文中bind VBO、EBO等数据类型，VBO就是在显存中分配一个内存块，GPU只用从这里取数据不用一直改所以很快。
新版本的OGL可以将VBO bind到VAO上方便定义和切换，老版本需要在draw循环中bind VBO；然后获取纹理数据到纹理单元（1-16个），其中包括格式转换和
格式定义等；最后就是在循环中draw，***清屏->激活VAO、 着色器->加载纹理->绘制->响应回调事件***。

* OpenGL坐标系统：屏幕零点坐标在中间，3D坐标系为右手坐标，z轴指向屏幕外，可视范围都在-1，1内。3D可视空间变换包括：模型矩阵、观察矩阵、
投影矩阵，模型矩阵的作用就是把物体放到合适的接近真实的大小和位置，观察矩阵就是看的方向和距离，投影（视角）矩阵就是截取视线角度和范围。
对于看不到的物体，可以开启深度测试，OpenGL会基于深度缓冲把绘制点与当前深度缓冲对比，丢弃小于它的点。

* 纹理：纹理就是细节图像，在VBO中可指定纹理坐标，纹理坐标和OpenGL的坐标不同，零点在左下角。可以通过设置一些纹理相关的宏实现不一样的效果，
比如环绕复制方式，采样方式等。GLSL中通过uniform类型传递纹理。

* 模板和帧缓冲：模板缓冲就是当前时刻存储一个固定矩阵，绘制时与固定矩阵加设置条件，这里设置条件可以任意，通常是绘制的位置模板值为1就不绘制。
绘制边框轮廓常用模板缓冲。帧缓冲就是数据内存，GLFW创建了默认帧缓冲，包括颜色、模板、深度的。可以通过glGenFramebuffers创建自定义帧缓冲，
然后给帧缓冲attach一个具体缓冲，最后分配renderbuffer数据(深度、模板)和texture数据内存。主循环要使用帧缓冲要bind加上具体数据，并和默认帧缓冲切换。
 
* 光照：光源叠加就是两个RGB相乘，对于被照物体就是在片段着色器上输出乘个颜色向量。冯氏光照模型包括环境光、（漫）反射光、镜面光，环境光就是光源
和物体即使不在也有一些光亮，漫反射就是光源对物体的影响，镜面光就是物体表面的影响。计算光照时距离不重要，方向重要，通过法线夹角计算漫反射，
镜面光由物体材质决定。光源属性包括点光源、平行光、距离衰减，多个光源、属性叠加也是相乘。

* 贴图：贴图就是纹理，传入的方式和纹理一样。光照贴图将采样值乘上光照分量有更真实的效果。

* 细分着色器：就是切点和线，增加点和线，可以自己定义分割方法，新增的点可以输入到几何着色器

* 几何着色器：对传入的顶点进行连线，决定几何形状。这里实现了法向量可视化的example，就是在绘制每个三角平面时加一个法向量线。

* 其他：
> 3D model对象：通过一些组件网格组成可直接加载的大模型，每一个组件mesh都要实现draw，相当于一个一个组件画
> 
> blending：混合颜色，实现不透明的效果，可通过宏开启
> 
> 面剔除：有一个宏控制，可剔除正向和反向面
> 
> 立方体贴图：将6张图放在空间中，这一部分包括折射、反射的计算函数
> 
> 高级数据：VBO中的数据改成自定义拼接格式
> 
> GLSL内建变量：内建变量就是提供了一些变量实现特殊的功能，比如点放大、自定义深度值、面剔除等。**接口块**就是一个结构体，uniform也有块结构。
> 
> 实例化：用于复制对象，通过模型矩阵在世界空间生成大量实体。
> 
> gamma矫正：用非线性曲线表示色阶
> 
> 抗锯齿：多重采样，一个光栅格子多个点
> 
> pixmap：基于ASCII编码的图像格式，其实也就是一张图片
> 
> 阴影贴图：光线向量计算出阴影范围，深度贴图：视线到物体的距离，法线贴图：根据颜色值改变法线
> 
> PBR：基于物理定律的渲染，根据一些物理公式
> 
> 调试错误查询glGetError，GLSL可以用颜色值调试输出



## 显卡知识
* PCIE：是计算机地址总线的一种，pci的延伸，有更快的速率和带宽,pcie插槽通道有1、4、8、16。PCIE的传输协议跟网络包有点像，也有帧头帧尾、
插帧去帧的过程，PCIE设备开发针对交换层的信息包TLP。显卡属于pcie设备隶属于总线空间。
* PCIE地址空间：PCIE设备有四类内存：configure space、io space、memory space、message。在上点bios阶段会读取configure space的信息，
包括显卡厂商信号，硬件版本等信息，中间部分映射物理地址的叫bar需要填写，通过读取bar的位长确定空间大小（有一段值是写死的，判断写死的最高位然后确定空间大小），
PCIE在memory低地址段有一段映射空间，映射DRAM（MMIO）到这里,这个空间叫IO地址空间,对于X86来说，IO采用独立编址，arm中的IO使用统一编址。为了兼容老版本的pci， 
memory空间中有相同的configure space。这里实现了cpu放内存或者io能访问到pcie域。
* 独显内存：MMIO的内存大小有时远小于独显内存，这是因为task中一次不需要这么大的dmabuffer，驱动不断的做新的dmabuffer并告诉gpu使用， 然后不断开新的buffer，只用转换显存其实地址就行。
* 显卡硬件：显卡不像CPU一样处理很多条件判断或冒险，流水线要保证高并发才能处理大量数据。显卡核心SIMD相当于处理单元，里面包含很多stream processer（core）
也就是线程资源，下面包含渲染管线（就是OGL中的管线）。显卡还包括电源模块、3D渲染模块、VCP（编解码），VPP（加速），内存，display等。
* display：framebuffer，plane（主平面 视频overlay 鼠标），crtc

## debug测试
* 串口调试：硬件需要串口转换线和usb转换线，启动的boot更改参数
* 内核调试：在内核模块中测试内核函数，printk打印内核消息，kgdb调试内核源码，公司驱动zx_info打印消息。
* 打log和看log：dmesg、查看驱动相关看kernel/debug、系统起来之前异常串口log、Xorg看var-log
* tool工具：gdb、debug-server
